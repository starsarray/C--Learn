# [C++学习之旅](https://www.runoob.com/cplusplus)

***
- [C++学习之旅](#c学习之旅)
  - [简介](#简介)
  - [基本语法](#基本语法)
    - [三字符组](#三字符组)
  - [注释](#注释)
  - [数据类型](#数据类型)
    - [基本的内置类型](#基本的内置类型)
    - [typedef 声明](#typedef-声明)
    - [枚举类型](#枚举类型)
    - [类型转换](#类型转换)
      - [静态转换（Static Cast）](#静态转换static-cast)
      - [动态转换（Dynamic Cast）](#动态转换dynamic-cast)
      - [常量转换（Const Cast）](#常量转换const-cast)
      - [重新解释转换（Reinterpret Cast）](#重新解释转换reinterpret-cast)
  - [变量类型](#变量类型)
  - [变量作用域](#变量作用域)
    - [初始化局部变量和全局变量](#初始化局部变量和全局变量)
  - [常量](#常量)
    - [整数常量](#整数常量)
    - [浮点常量](#浮点常量)
    - [定义常量](#定义常量)
  - [修饰符类型](#修饰符类型)
    - [C++ 中的类型限定符](#c-中的类型限定符)
  - [C++ 存储类](#c-存储类)
    - [thread\_local 存储类](#thread_local-存储类)
  - [运算符](#运算符)
    - [算术运算符](#算术运算符)
    - [杂项运算符](#杂项运算符)
    - [运算符优先级](#运算符优先级)
    - [函数](#函数)
    - [函数参数](#函数参数)
    - [Lambda 函数与表达式](#lambda-函数与表达式)
  - [数字](#数字)
    - [C++ 随机数](#c-随机数)
  - [数组](#数组)
  - [字符串](#字符串)
    - [C 风格字符串](#c-风格字符串)
    - [C++ 中的 String 类](#c-中的-string-类)
  - [指针](#指针)
  - [引用](#引用)
    - [C++ 引用 vs 指针](#c-引用-vs-指针)


***

## 简介

**面相对象程序设计**

**四**大特性：

- **封装（Encapsulation）**：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。
- **继承（Inheritance）**：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性。
- **多态（Polymorphism）**：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。
- **抽象（Abstraction）**：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。

***

## 基本语法

*C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。*

- **对象 -** 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。
- **类 -** 类可以定义为描述对象行为/状态的模板/蓝图。
- **方法 -** 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。
- **即时变量 -** 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。

### 三字符组

用于表示另一个字符的**三个**字符序列，以两个**问号**开头

| 三字符组 | 替换 |
| :------- | :--- |
| ??=      | #    |
| ??/      | \    |
| ??'      | ^    |
| ??(      | [    |
| ??)      | ]    |
| ??!      | \|   |
| ??<      | {    |
| ??>      | }    |
| ??-      | ~    |

一般不常用，但是想使用**两个问号不被替换**，可以用**字符串**的自动连接："...?""?..."或者**转义序列**："...?\?..."

***

## 注释

程序的注释是**解释性语句**

C++ 注释一般有两种：

- **//** - 一般用于单行注释
- /*** ... \*/** - 一般用于多行注释

***

## 数据类型

### 基本的内置类型

七种基本的 C++ 数据类型：

| 类型     | 关键字  |
| :------- | :------ |
| 布尔型   | bool    |
| 字符型   | char    |
| 整型     | int     |
| 浮点型   | float   |
| 双浮点型 | double  |
| 无类型   | void    |
| 宽字符型 | wchar_t |

其实 wchar_t 是这样来的：

```
typedef short int wchar_t;
```

所以 wchar_t 实际上的空间是和 short int 一样。

一些基本类型可以使用一个或多个类型修饰符进行修饰：

- signed

- unsigned

- short

- long

***各种类型的存储大小与系统位数、编译器有关***
| 类型               | 位            | 范围                                                         |
| :----------------- | :------------ | :----------------------------------------------------------- |
| char               | 1 个字节      | -128 到 127 或者 0 到 255                                    |
| unsigned char      | 1 个字节      | 0 到 255                                                     |
| signed char        | 1 个字节      | -128 到 127                                                  |
| int                | 4 个字节      | -2147483648 到 2147483647                                    |
| unsigned int       | 4 个字节      | 0 到 4294967295                                              |
| signed int         | 4 个字节      | -2147483648 到 2147483647                                    |
| short int          | 2 个字节      | -32768 到 32767                                              |
| unsigned short int | 2 个字节      | 0 到 65,535                                                  |
| signed short int   | 2 个字节      | -32768 到 32767                                              |
| long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| unsigned long int  | 8 个字节      | 0 到 18,446,744,073,709,551,615                              |
| float              | 4 个字节      | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) |
| double             | 8 个字节      | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) |
| long long          | 8 个字节      | 双精度型占8 个字节（64位）内存空间，表示 -9,223,372,036,854,775,807 到 9,223,372,036,854,775,807 的范围 |
| long double        | 16 个字节     | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |
| wchar_t            | 2 或 4 个字节 | 1 个宽字符                                                   |

### typedef 声明

使用 **typedef** 为一个已有的类型取一个新的名字

下面的语句会告诉编译器，feet 是 int 的另一个名称：

```c++
typedef int feet;
```

### 枚举类型

枚举类型(enumeration)是C++中的一种**派生**数据类型

使用关键字 **enum**将变量的值一一列举出来：

```c++
enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
    标识符[=整型常数]
} 枚举变量;
    
```

默认情况下，第一个名称的值为 0，后面比前一个大一

```c++
enum color { red, green=5, blue };
```

在这里，**blue** 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0

### 类型转换

C++ 中有四种类型转换：**静态转换**、**动态转换**、**常量转换**和**重新解释转换**

#### 静态转换（Static Cast）

- 静态转换是将一种数据类型的值强制转换为另一种数据类型的值

- 静态转换通常用于比较**类型相似**的对象之间的转换，例如将 int 类型转换为 float 类型

- 静态转换不进行任何运行时类型检查，因此可能会导致运行时错误

```c++
int i = 10;
float f = static_cast<float>(i); // 静态将int类型转换为float类型
```

#### 动态转换（Dynamic Cast）

- 动态转换通常用于将一个基类指针或引用转换为派生类指针或引用
- 动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常

```c++
class Base {};
class Derived : public Base {};
Base* ptr_base = new Derived;
Derived* ptr_derived = dynamic_cast<Derived*>(ptr_base); // 将基类指针转换为派生类指针
```

#### 常量转换（Const Cast）

- 常量转换用于将 const 类型的对象转换为非 const 类型的对象

- 常量转换只能用于转换掉 const 属性，不能改变对象的类型

```C++
const int i = 10;
int& r = const_cast<int&>(i); // 常量转换，将const int转换为int
```

#### 重新解释转换（Reinterpret Cast）

- 重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换

- 重新解释转换不进行任何类型检查，因此可能会导致未定义的行为

```c++
int i = 10;
float f = reinterpret_cast<float&>(i); // 重新解释将int类型转换为float类型
```

***

## 变量类型

*C++ 标准规定的最小要求*：

1. 整数类型（Integer Types）：
   - `int`：用于表示整数，通常占用4个字节。
   - `short`：用于表示短整数，通常占用2个字节。
   - `long`：用于表示长整数，通常占用4个字节。
   - `long long`：用于表示更长的整数，通常占用8个字节。
2. 浮点类型（Floating-Point Types）：
   - `float`：用于表示单精度浮点数，通常占用4个字节。![img](https://www.runoob.com/wp-content/uploads/2014/09/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png)
   - `double`：用于表示双精度浮点数，通常占用8个字节。![img](https://www.runoob.com/wp-content/uploads/2014/09/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.png)
   - `long double`：用于表示更高精度的浮点数，占用字节数可以根据实现而变化。
3. 字符类型（Character Types）：
   - `char`：用于表示字符，通常占用1个字节。
   - `wchar_t`：用于表示宽字符，通常占用2或4个字节。
   - `char16_t`：用于表示16位Unicode字符，占用2个字节。
   - `char32_t`：用于表示32位Unicode字符，占用4个字节。
4. 布尔类型（Boolean Type）：
   - `bool`：用于表示布尔值，只能取`true`或`false`。
5. 枚举类型（Enumeration Types）：
   - `enum`：用于定义一组命名的整数常量。
6. 指针类型（Pointer Types）：
   - `type*`：用于表示指向类型为`type`的对象的指针。
7. 数组类型（Array Types）：
   - `type[]`或`type[size]`：用于表示具有相同类型的元素组成的数组。
8. 结构体类型（Structure Types）：
   - `struct`：用于定义包含多个不同类型成员的结构。
9. 类类型（Class Types）：
   - `class`：用于定义具有属性和方法的自定义类型。
10. 共用体类型（Union Types）：
    - `union`：用于定义一种特殊的数据类型，它可以在相同的内存位置存储不同的数据类型。

***

## 变量作用域

如果在内部作用域中声明的变量与外部作用域中的变量同名，则内部作用域中的变量将覆盖外部作用域中的变量

### 初始化局部变量和全局变量

当局部变量被定义时，必须自行对其初始化，否则是当前内存以前的值

定义全局变量时，系统会自动初始化为下列值：

| 数据类型 | 初始化默认值 |
| :------- | :----------- |
| int      | 0            |
| char     | '\0'         |
| float    | 0            |
| double   | 0            |
| pointer  | NULL         |

作用域解析运算符 **::**

***

## 常量

*常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量***

*可分为**整型数字、浮点数字、字符、字符串和布尔值***

### 整数常量

前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制

后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意

### 浮点常量

浮点常量由**整数部分**、**小数点**、**小数部分**和**指数部分**组成

使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者

使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的

### 定义常量

在 C++ 中，两种简单的定义常量的方式：

- 使用 **#define** 预处理器。
- 使用 **const** 关键字。

**通常把常量定义为大写字母形式**

***

## 修饰符类型

### C++ 中的类型限定符

类型限定符提供了变量的额外信息，用于在定义变量或函数时改变它们的默认行为的关键字。

| 限定符   | 含义                                                         |
| :------- | :----------------------------------------------------------- |
| const    | **const** 定义常量，表示该变量的值不能被修改。               |
| volatile | 修饰符 **volatile** 告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程。。 |
| restrict | 由 **restrict** 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 |
| mutable  | mutable 用于修饰类的成员变量。被 mutable 修饰的成员变量可以被修改，即使它们所在的对象是 const 的。 |
| static   | 用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问。 |
| register | 用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率。在 C++11 及以后的版本中，register 已经是一个废弃的特性，不再具有实际作用。 |

**mutable 实例**

**特点：**

- **允许修改**：`mutable` 成员变量可以在 `const` 成员函数内被改变。
- **设计目的**：通常用于需要在不改变对象外部状态的情况下进行状态管理的场景，比如缓存、延迟计算等。

```c++
class Example {
public:
    int get_value() const {
        return value_; // const 关键字表示该成员函数不会修改对象中的数据成员
    }
    void set_value(int value) const {
        value_ = value; // mutable 关键字允许在 const 成员函数中修改成员变量
    }
private:
    mutable int value_;
};
```

**register 实例**

```c++
void example_function(register int num) {
    // register 关键字建议编译器将变量 num 存储在寄存器中
    // 以提高程序执行速度
    // 但是实际上是否会存储在寄存器中由编译器决定
}
```

***

## C++ 存储类

存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：

- **auto**：这是默认的存储类说明符，通常可以省略不写。auto 指定的变量具有自动存储期，即它们的生命周期仅限于定义它们的块（block）。auto 变量通常在栈上分配。
- **register**：用于建议编译器将变量存储在CPU寄存器中以提高访问速度。在 C++11 及以后的版本中，register 已经是一个废弃的特性，不再具有实际作用。
- **static**：用于定义具有静态存储期的变量或函数，它们的生命周期贯穿整个程序的运行期。在函数内部，static变量的值在函数调用之间保持不变。在文件内部或全局作用域，static变量具有内部链接，只能在定义它们的文件中访问。
- **extern**：用于声明具有外部链接的变量或函数，它们可以在多个文件之间共享。默认情况下，全局变量和函数具有 extern 存储类。在一个文件中使用extern声明另一个文件中定义的全局变量或函数，可以实现跨文件共享。
- **mutable (C++11)**：用于修饰类中的成员变量，允许在const成员函数中修改这些变量的值。通常用于缓存或计数器等需要在const上下文中修改的数据。
- **thread_local (C++11)**：用于定义具有线程局部存储期的变量，每个线程都有自己的独立副本。线程局部变量的生命周期与线程的生命周期相同。

### thread_local 存储类

thread_local 是 C++11 引入的一种存储类，用于在多线程环境中管理线程特有的变量。

使用 thread_local 修饰的变量在每个线程中都有独立的实例，因此每个线程对该变量的操作不会影响其他线程。

- **独立性**：每个线程都有自己独立的变量副本，不同线程之间的读写操作互不干扰。
- **生命周期**：`thread_local` 变量在其线程结束时自动销毁。
- **初始化**：`thread_local` 变量可以进行静态初始化或动态初始化，支持在声明时初始化。

thread_local 适合用于需要存储线程状态、缓存或者避免数据竞争的场景，如线程池、请求上下文等。

***

## 运算符

运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：

- 算术运算符
- 关系运算符
- 逻辑运算符
- 位运算符
- 赋值运算符
- 杂项运算符
- 算术运算符

### 算术运算符

| 运算符 | 描述                                                         | 实例          |
| :----- | :----------------------------------------------------------- | :------------ |
| ++     | [自增运算符](https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html)，整数值增加 1 | A++ 将得到 11 |
| --     | [自减运算符](https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html)，整数值减少 1 | A-- 将得到 9  |

### 杂项运算符

下表列出了 C++ 支持的其他一些重要的运算符。

| 运算符               | 描述                                                         |
| :------------------- | :----------------------------------------------------------- |
| sizeof               | [sizeof 运算符](https://www.runoob.com/cplusplus/cpp-sizeof-operator.html)返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 |
| Condition ? X : Y    | [条件运算符](https://www.runoob.com/cplusplus/cpp-conditional-operator.html)。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 |
| ,                    | [逗号运算符](https://www.runoob.com/cplusplus/cpp-comma-operator.html)会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 |
| .（点）和 ->（箭头） | [成员运算符](https://www.runoob.com/cplusplus/cpp-member-operators.html)用于引用类、结构和共用体的成员。 |
| Cast                 | [强制转换运算符](https://www.runoob.com/cplusplus/cpp-casting-operators.html)把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 |
| &                    | [指针运算符 &](https://www.runoob.com/cplusplus/cpp-pointer-operators.html) 返回变量的地址。例如 &a; 将给出变量的实际地址。 |
| *                    | [指针运算符 *](https://www.runoob.com/cplusplus/cpp-pointer-operators.html) 指向一个变量。例如，*var; 将指向变量 var。 |

### 运算符优先级

| 类别       | 运算符                            | 结合性   |
| :--------- | :-------------------------------- | :------- |
| 后缀       | () [] -> . ++ - -                 | 从左到右 |
| 一元       | + - ! ~ ++ - - (type)* & sizeof   | 从右到左 |
| 乘除       | * / %                             | 从左到右 |
| 加减       | + -                               | 从左到右 |
| 移位       | << >>                             | 从左到右 |
| 关系       | < <= > >=                         | 从左到右 |
| 相等       | == !=                             | 从左到右 |
| 位与 AND   | &                                 | 从左到右 |
| 位异或 XOR | ^                                 | 从左到右 |
| 位或 OR    | \|                                | 从左到右 |
| 逻辑与 AND | &&                                | 从左到右 |
| 逻辑或 OR  | \|\|                              | 从左到右 |
| 条件       | ?:                                | 从右到左 |
| 赋值       | = += -= *= /= %=>>= <<= &= ^= \|= | 从右到左 |
| 逗号       | ,                                 | 从左到右 |

***

### 函数

*每个 C++ 程序都至少有一个函数，即主函数* **main()** 

*函数还有很多叫法，比如方法、子例程或程序，等等*

### 函数参数

如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。

形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。

当调用函数时，有三种向函数传递参数的方式：

| 调用类型                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [传值调用](https://www.runoob.com/cplusplus/cpp-function-call-by-value.html) | 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 |
| [指针调用](https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html) | 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |
| [引用调用](https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html) | 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |

### Lambda 函数与表达式

C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。

Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。

Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:

```c++
[capture](parameters)->return-type{body}
```

```c++
[](int x, int y) -> int { int z = x + y; return z + x; }
```

在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：

```c++
[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```

另外有一点需要注意。对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：

```c++
[this]() { this->someFunc(); }();
```

***

## 数字

C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。

为了利用这些函数，您需要引用数学头文件 **<cmath>**。

| 序号 | 函数 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **double cos(double);** 该函数返回弧度角（double 型）的余弦。 |
| 2    | **double sin(double);** 该函数返回弧度角（double 型）的正弦。 |
| 3    | **double tan(double);** 该函数返回弧度角（double 型）的正切。 |
| 4    | **double log(double);** 该函数返回参数的自然对数。           |
| 5    | **double pow(double, double);** 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 |
| 6    | **double hypot(double, double);** 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 |
| 7    | **double sqrt(double);** 该函数返回参数的平方根。            |
| 8    | **int abs(int);** 该函数返回整数的绝对值。                   |
| 9    | **double fabs(double);** 该函数返回任意一个浮点数的绝对值。  |
| 10   | **double floor(double);** 该函数返回一个小于或等于传入参数的最大整数。 |

### C++ 随机数

关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 **srand()** 函数

```c++
#include <iostream>
#include <ctime>
#include <cstdlib>
using namespace std;
int main ()
{
   int i,j;
   srand( (unsigned)time( NULL ) );// 设置种子
   /* 生成 10 个随机数 */
   for( i = 0; i < 10; i++ )
   {
      j= rand();// 生成实际的随机数
      cout <<"随机数： " << j << endl;
   }
   return 0;
}
```

***

## 数组



| 概念                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [多维数组](https://www.runoob.com/cplusplus/cpp-multi-dimensional-arrays.html) | C++ 支持多维数组。多维数组最简单的形式是二维数组。           |
| [指向数组的指针](https://www.runoob.com/cplusplus/cpp-pointer-to-an-array.html) | 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 |
| [传递数组给函数](https://www.runoob.com/cplusplus/cpp-passing-arrays-to-functions.html) | 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 |
| [从函数返回数组](https://www.runoob.com/cplusplus/cpp-return-arrays-from-function.html) | C++ 允许从函数返回数组。                                     |

***

## 字符串

C++ 提供了以下两种类型的字符串表示形式：

- C 风格字符串
- C++ 引入的 string 类类型

### C 风格字符串

得加上`#include <cstring>`

| 序号 | 函数 & 目的                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |
| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 **+** 号，例如: `string str1 = "runoob"; string str2 = "google"; string str = str1 + str2;` |
| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |
| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。 |
| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |
| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |

### C++ 中的 String 类

得加上`#include <string>`

- 复制直接用`=`
- 连接字符串用`+`
- 字符串变量后接`.size()`获取长度

***

## 指针

**指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。

| 概念                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [C++ Null 指针](https://www.runoob.com/cplusplus/cpp-null-pointers.html) | C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 |
| [C++ 指针的算术运算](https://www.runoob.com/cplusplus/cpp-pointer-arithmetic.html) | 可以对指针进行四种算术运算：++、--、+、-                     |
| [C++ 指针 vs 数组](https://www.runoob.com/cplusplus/cpp-pointers-vs-arrays.html) | 指针和数组之间有着密切的关系。                               |
| [C++ 指针数组](https://www.runoob.com/cplusplus/cpp-array-of-pointers.html) | 可以定义用来存储指针的数组。                                 |
| [C++ 指向指针的指针](https://www.runoob.com/cplusplus/cpp-pointer-to-pointer.html) | C++ 允许指向指针的指针。                                     |
| [C++ 传递指针给函数](https://www.runoob.com/cplusplus/cpp-passing-pointers-to-functions.html) | 通过引用或地址传递参数，使传递的参数在调用函数中被改变。     |
| [C++ 从函数返回指针](https://www.runoob.com/cplusplus/cpp-return-pointer-from-functions.html) | C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。     |

***

## 引用

引用变量是一个别名，是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

### C++ 引用 vs 指针

引用很容易与指针混淆，它们之间有三个主要的不同：

- 不存在空引用。引用必须连接到一块合法的内存。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。

| 概念                                                         | 描述                                                     |
| :----------------------------------------------------------- | :------------------------------------------------------- |
| [把引用作为参数](https://www.runoob.com/cplusplus/passing-parameters-by-references.html) | C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 |
| [把引用作为返回值](https://www.runoob.com/cplusplus/returning-values-by-reference.html) | 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。    |

***

## 输入输出

*C++ 的 I/O 发生在流中，流是字节序列。*

| 头文件                                                       | 函数和描述                                                   |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [<iostream>](https://www.runoob.com/cplusplus/cpp-libs-iostream.html) | 该文件定义了 **cin、cout、cerr** 和 **clog** 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 |
| [<iomanip>](https://www.runoob.com/cplusplus/cpp-libs-iomanip.html) | 该文件通过所谓的参数化的流操纵器（比如 **setw** 和 **setprecision**），来声明对执行标准化 I/O 有用的服务。 |
| [<fstream>](https://www.runoob.com/cplusplus/cpp-libs-fstream.html) | 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 |

***

## 结构体

C/C++ 数组允许定义可存储相同类型数据项的变量

而**结构**是 C++ 中另一种用户自定义的可用的数据类型，允许存储不同类型的数据项

**结构体优点：**

- **简单数据封装**：适合封装多种类型的简单数据，通常用于数据的存储
- **轻量级**：相比 `class`，结构体语法更简洁，适合小型数据对象
- **面向对象支持**：支持构造函数、成员函数和访问权限控制，可以实现面向对象的设计

### 结构体的各个部分详细介绍

- **struct 关键字：**用于定义结构体，它告诉编译器后面要定义的是一个自定义类型
- **成员变量：**成员变量是结构体中定义的数据项，它们可以是任何基本类型或其他自定义类型。在 struct 中，这些成员默认是 public，可以直接访问
- **成员函数：**结构体中也可以包含成员函数，这使得结构体在功能上类似于类。成员函数可以操作结构体的成员变量，提供对数据的封装和操作
- **访问权限：**与 class 类似，你可以在 struct 中使用 public、private 和 protected 来定义成员的访问权限。在 struct 中，默认所有成员都是 public，而 class 中默认是 private

### 指向结构的指针

必须使用 `-> `运算符访问

***

## vector 容器

vector 是基于数组的数据结构，可以自动管理内存

要使用 vector，首先需要包含 **<vector>** 头文件

**创建 Vector**

```C++
std::vector<int> myVector; // 创建一个存储整数的空 vector
```

这将创建一个空的整数向量,也可以在创建时指定初始大小和初始值：

```C++
std::vector<int> myVector(5); // 创建一个包含 5 个整数的 vector，每个值都为默认值（0）
std::vector<int> myVector(5, 10); // 创建一个包含 5 个整数的 vector，每个值都为 10
```

或：

```C++
std::vector<int> vec; // 默认初始化一个空的 vector
std::vector<int> vec2 = {1, 2, 3, 4}; // 初始化一个包含元素的 vector
```

**添加元素**

可以使用 push_back 方法向 vector 中添加元素：

```C++
myVector.push_back(7); // 将整数 7 添加到 vector 的末尾
```

**访问元素**

可以使用下标操作符 [] 或 at() 方法访问 vector 中的元素：

```C++
int x = myVector[0]; // 获取第一个元素
int y = myVector.at(1); // 获取第二个元素
```

**获取大小**

可以使用 size() 方法获取 vector 中元素的数量：

```C++
int size = myVector.size(); // 获取 vector 中的元素数量
```

**迭代访问**

可以使用迭代器遍历 vector 中的元素：

```C++
for (auto it = myVector.begin(); it != myVector.end(); ++it) {
    std::cout << *it << " ";
}
```

或者使用范围循环：

```C++
for (int element : myVector) {
    std::cout << element << " ";
}
```

**删除元素**

可以使用 erase() 方法删除 vector 中的元素：

```C++
myVector.erase(myVector.begin() + 2); // 删除第三个元素
```

**清空 Vector**

可以使用 clear() 方法清空 vector 中的所有元素：

```C++
myVector.clear(); // 清空 vector
```

***

## 数据结构

### **数组（Array）**

数组是最基础的数据结构，用于存储一组相同类型的数据。

**特点**：

- 固定大小，一旦声明，大小不能改变
- 直接访问元素，时间复杂度为 O(1)
- 适合处理大小已知、元素类型相同的集合

**优缺点**：

- 优点：访问速度快，内存紧凑
- 缺点：大小固定，无法动态扩展，不适合处理大小不确定的数据集

### **结构体（Struct）**

结构体允许将不同类型的数据组合在一起，形成一种自定义的数据类型

**特点**：

- 可以包含不同类型的成员变量
- 提供了对数据的基本封装，但功能有限

### **类（Class）**

类是 C++ 中用于面向对象编程的核心结构，允许定义成员变量和成员函数

与 `struct` 类似，但功能更强大，支持继承、封装、多态等特性

**特点**：

- 可以包含成员变量、成员函数、构造函数、析构函数
- 支持面向对象特性，如封装、继承、多态

### **链表（Linked List）**

链表是一种动态数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针

**特点**：

- 动态调整大小，不需要提前定义容量
- 插入和删除操作效率高，时间复杂度为 O(1)（在链表头部或尾部操作）
- 线性查找，时间复杂度为 O(n)

**优缺点**：

- 优点：动态大小，适合频繁插入和删除的场景
- 缺点：随机访问效率低，不如数组直接访问快

### **栈（Stack）**

栈是一种后进先出（LIFO, Last In First Out）的数据结构，常用于递归、深度优先搜索等场景

**特点**：

- 只允许在栈顶进行插入和删除操作
- 时间复杂度为 O(1)

**优缺点**：

- 优点：操作简单，效率高
- 缺点：只能在栈顶操作，访问其他元素需要弹出栈顶元素

### **队列（Queue）**

队列是一种先进先出（FIFO, First In First Out）的数据结构，常用于广度优先搜索、任务调度等场景

**特点**：

- 插入操作在队尾进行，删除操作在队头进行
- 时间复杂度为 O(1)

**优缺点**：

- 优点：适合按顺序处理数据的场景，如任务调度
- 缺点：无法随机访问元素

### **双端队列（Deque）**

双端队列允许在两端进行插入和删除操作，是栈和队列的结合体

**特点**：

- 允许在两端进行插入和删除
- 时间复杂度为 O(1)

**优缺点**：

- 优点：灵活的双向操作
- 缺点：空间占用较大，适合需要在两端频繁操作的场景

### **哈希表（Hash Table）**

哈希表是一种通过键值对存储数据的数据结构，支持快速查找、插入和删除操作。C++ 中的 `unordered_map` 是哈希表的实现

**特点**：

- 使用哈希函数快速定位元素，时间复杂度为 O(1)
- 不保证元素的顺序

**优缺点**：

- 优点：查找、插入、删除操作效率高
- 缺点：无法保证元素顺序，哈希冲突时性能会下降

### **映射（Map）**

`map` 是一种有序的键值对容器，底层实现是红黑树。与 `unordered_map` 不同，它保证键的顺序，查找、插入和删除的时间复杂度为 O(log n)

**特点**：

- 保证元素按键的顺序排列
- 使用二叉搜索树实现

**优缺点**：

- 优点：元素有序，适合需要按顺序处理数据的场景。
- 缺点：操作效率比 `unordered_map` 略低。

### **集合（Set）**

`set` 是一种用于存储唯一元素的有序集合，底层同样使用红黑树实现。它保证元素不重复且有序

**特点**：

- 保证元素的唯一性
- 元素自动按升序排列
- 时间复杂度为 O(log n)

**优缺点**：

- 优点：自动排序和唯一性保证
- 缺点：插入和删除的效率不如无序集合

### **动态数组（Vector）**

`vector` 是 C++ 标准库提供的动态数组实现，可以动态扩展容量，支持随机访问

**特点**：

- 动态调整大小。
- 支持随机访问，时间复杂度为 O(1)
- 当容量不足时，动态扩展，时间复杂度为摊销 O(1)

**优缺点**：

- 优点：支持随机访问，动态扩展
- 缺点：插入和删除中间元素的效率较低

***

## 类&对象

| 概念                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [类成员函数](https://www.runoob.com/cplusplus/cpp-class-member-functions.html) | 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 |
| [类访问修饰符](https://www.runoob.com/cplusplus/cpp-class-access-modifiers.html) | 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 |
| [构造函数 & 析构函数](https://www.runoob.com/cplusplus/cpp-constructor-destructor.html) | 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 |
| [C++ 拷贝构造函数](https://www.runoob.com/cplusplus/cpp-copy-constructor.html) | 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 |
| [C++ 友元函数](https://www.runoob.com/cplusplus/cpp-friend-functions.html) | **友元函数**可以访问类的 private 和 protected 成员。         |
| [C++ 内联函数](https://www.runoob.com/cplusplus/cpp-inline-functions.html) | 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 |
| [C++ 中的 this 指针](https://www.runoob.com/cplusplus/cpp-this-pointer.html) | 每个对象都有一个特殊的指针 **this**，它指向对象本身。        |
| [C++ 中指向类的指针](https://www.runoob.com/cplusplus/cpp-pointer-to-class.html) | 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 |
| [C++ 类的静态成员](https://www.runoob.com/cplusplus/cpp-static-members.html) | 类的数据成员和函数成员都可以被声明为静态的。                 |

***

**构造函数**的名称与类的名称是完全相同的，并且**不会返回任何类型**，也不会返回 void

**析构函数**的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它**不会返回任何值，也不能带有任何参数**

如果在类中没有定义**拷贝构造函数**，编译器会自行定义一个。如果类带有**指针变量**，并有动态内存分配，则它必须有一个拷贝构造函数

***

## 继承

| 访问     | public | protected | private |
| :------- | :----- | :-------- | :------ |
| 同一个类 | yes    | yes       | yes     |
| 派生类   | yes    | yes       | no      |
| 外部的类 | yes    | no        | no      |

***

## 重载

| 序号 | 运算符和实例                                                 |
| :--- | :----------------------------------------------------------- |
| 1    | [一元运算符重载](https://www.runoob.com/cplusplus/unary-operators-overloading.html) |
| 2    | [二元运算符重载](https://www.runoob.com/cplusplus/binary-operators-overloading.html) |
| 3    | [关系运算符重载](https://www.runoob.com/cplusplus/relational-operators-overloading.html) |
| 4    | [输入/输出运算符重载](https://www.runoob.com/cplusplus/input-output-operators-overloading.html) |
| 5    | [++ 和 -- 运算符重载](https://www.runoob.com/cplusplus/increment-decrement-operators-overloading.html) |
| 6    | [赋值运算符重载](https://www.runoob.com/cplusplus/assignment-operators-overloading.html) |
| 7    | [函数调用运算符 () 重载](https://www.runoob.com/cplusplus/function-call-operator-overloading.html) |
| 8    | [下标运算符 [\] 重载](https://www.runoob.com/cplusplus/subscripting-operator-overloading.html) |
| 9    | [类成员访问运算符 -> 重载](https://www.runoob.com/cplusplus/class-member-access-operator-overloading.html) |

***

## 多态

**使用多态的优势**：

- **代码复用**：通过基类指针或引用，可以操作不同类型的派生类对象，实现代码的复用。
- **扩展性**：新增派生类时，不需要修改依赖于基类的代码，只需要确保新类正确重写了虚函数。
- **解耦**：多态允许程序设计更加模块化，降低类之间的耦合度。

- **虚函数与纯虚函数的对比**

- | 特性     | 虚函数（Virtual Function）        | 纯虚函数（Pure Virtual Function） |
  | :------- | :-------------------------------- | :-------------------------------- |
  | 定义     | 基类中使用 `virtual` 声明，有实现 | 基类中使用 `= 0` 声明，无实现     |
  | 子类重写 | 子类可以选择重写                  | 子类必须实现                      |
  | 抽象性   | 可以实例化类                      | 使类变为抽象类，无法实例化        |
  | 用途     | 提供默认行为，允许子类重写        | 定义接口，强制子类实现具体行为    |

***

## 数据抽象

- 数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节

- 数据抽象是一种依赖于接口和实现分离的编程（设计）技术

数据抽象有两个重要的**优势**：

- 类的内部受到保护，不会因无意的用户级错误导致对象状态受损
- 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告

***

## 数据封装

所有的 C++ 程序都有以下两个基本要素：

- **程序语句（代码）：**这是程序中执行动作的部分，它们被称为函数。
- **程序数据：**数据是程序的信息，会受到程序函数的影响。

封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即**数据隐藏**。

**数据封装**是一种把数据和操作数据的函数**捆绑**在一起的机制，

**数据抽象**是一种仅向用户暴露接口而把具体的实现**细节隐藏**起来的机制。

C++ 通过创建**类**来支持封装和数据隐藏（public、protected、private）。

**数据封装的优点**

- **数据隐藏**: 通过将数据成员声明为私有，防止外部代码直接访问这些数据。
- **提高代码可维护性**: 提供公共方法来访问和修改数据，这使得可以在不影响外部代码的情况下修改类的内部实现。
- **增强安全性**: 防止不合法的数据输入和不当的修改操作。
- **实现抽象**: 提供了一种机制，使得用户不需要了解类的内部实现细节，只需要了解如何使用类的公共接口即可。

***

## 接口（抽象类）

- C++ 接口是使用**抽象类**来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念

- 如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类

- 设计**抽象类**（通常称为 ABC）
- 可用于实例化对象的类被称为**具体类**
